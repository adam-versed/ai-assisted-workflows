// {{ file.path }} - PostHog Middleware for Next.js
// Generated from PRD requirements
{% if file.options.nextjs %}
// ADVICE: Use this middleware in Next.js to track page views and API calls automatically
{% endif %}
{% if file.options.privacy %}
// ADVICE: Middleware allows filtering requests before tracking for privacy compliance
{% endif %}

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { PostHog } from 'posthog-node';

// Initialize PostHog for middleware
let postHogMiddleware: PostHog | null = null;

function getPostHogMiddleware(): PostHog {
  if (!postHogMiddleware) {
    const apiKey = process.env.POSTHOG_API_KEY;

    if (!apiKey) {
      console.warn('POSTHOG_API_KEY not found - PostHog tracking disabled in middleware');
      throw new Error('PostHog API key required');
    }

    postHogMiddleware = new PostHog(apiKey, {
      host: process.env.POSTHOG_HOST || 'https://us.i.posthog.com',
      flushAt: 1, // Flush immediately in middleware
      flushInterval: 1000,
    });
  }

  return postHogMiddleware;
}

{% for function in functions %}
{% if 'middleware' in function.name.lower() %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export function {{ function.name }}(request: NextRequest) {
  const response = NextResponse.next();

  // Skip tracking for certain paths
  if (shouldSkipTracking(request)) {
    return response;
  }

  try {
    const postHog = getPostHogMiddleware();
    const distinctId = getDistinctId(request);

    // Track page views for non-API routes
    if (!request.nextUrl.pathname.startsWith('/api/')) {
      trackPageView(postHog, distinctId, request);
    }

    // Track API calls
    if (request.nextUrl.pathname.startsWith('/api/')) {
      trackAPICall(postHog, distinctId, request);
    }

    {% if file.options.privacy %}
    // Add privacy headers
    response.headers.set('X-PostHog-Tracking', 'enabled');
    {% endif %}

  } catch (error) {
    console.error('PostHog middleware error:', error);
    // Don't block requests if PostHog fails
  }

  return response;
}

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// Helper functions
function shouldSkipTracking(request: NextRequest): boolean {
  const pathname = request.nextUrl.pathname;

  // Skip tracking for these paths
  const skipPaths = [
    '/_next/',
    '/favicon.ico',
    '/robots.txt',
    '/sitemap.xml',
    '/health',
    '/api/health',
    {% if file.options.privacy %}
    '/api/posthog', // Don't track PostHog API calls
    {% endif %}
  ];

  return skipPaths.some(path => pathname.startsWith(path));
}

function getDistinctId(request: NextRequest): string {
  // Try to get user ID from various sources
  const authHeader = request.headers.get('authorization');
  const sessionCookie = request.cookies.get('session')?.value;
  const postHogId = request.cookies.get('ph_distinct_id')?.value;

  // Use authenticated user ID if available
  if (authHeader && authHeader.startsWith('Bearer ')) {
    // TODO: Implement JWT decode to get user ID
    // const userId = decodeJWT(authHeader.replace('Bearer ', ''));
    // return userId;
  }

  // Use session-based ID if available
  if (sessionCookie) {
    // TODO: Implement session decode to get user ID
    // const userId = decodeSession(sessionCookie);
    // return userId;
  }

  // Use PostHog's existing distinct ID
  if (postHogId) {
    return postHogId;
  }

  // Fallback to anonymous ID based on IP + User Agent
  const ip = getClientIP(request);
  const userAgent = request.headers.get('user-agent') || '';
  return `anon_${hashString(`${ip}_${userAgent}`)}`;
}

function trackPageView(postHog: PostHog, distinctId: string, request: NextRequest): void {
  const pathname = request.nextUrl.pathname;
  const searchParams = request.nextUrl.search;

  {% if file.options.privacy %}
  // Remove sensitive query parameters
  const sanitizedSearch = sanitizeSearchParams(searchParams);
  {% else %}
  const sanitizedSearch = searchParams;
  {% endif %}

  postHog.capture({
    distinctId,
    event: '$pageview',
    properties: {
      $current_url: `${pathname}${sanitizedSearch}`,
      pathname,
      referrer: request.headers.get('referer'),
      user_agent: request.headers.get('user-agent'),
      {% if file.options.privacy %}
      // Don't include IP address for privacy
      {% else %}
      ip_address: getClientIP(request),
      {% endif %}
      middleware_tracked: true,
    },
  });
}

function trackAPICall(postHog: PostHog, distinctId: string, request: NextRequest): void {
  const pathname = request.nextUrl.pathname;
  const method = request.method;

  postHog.capture({
    distinctId,
    event: 'api request initiated',
    properties: {
      endpoint: pathname,
      method: method.toUpperCase(),
      user_agent: request.headers.get('user-agent'),
      referrer: request.headers.get('referer'),
      {% if file.options.privacy %}
      // Don't include IP address for privacy
      {% else %}
      ip_address: getClientIP(request),
      {% endif %}
      middleware_tracked: true,
    },
  });
}

function getClientIP(request: NextRequest): string {
  // Try various headers to get client IP
  const xForwardedFor = request.headers.get('x-forwarded-for');
  const xRealIp = request.headers.get('x-real-ip');
  const cfConnectingIp = request.headers.get('cf-connecting-ip');

  if (xForwardedFor) {
    return xForwardedFor.split(',')[0].trim();
  }

  if (xRealIp) {
    return xRealIp;
  }

  if (cfConnectingIp) {
    return cfConnectingIp;
  }

  return 'unknown';
}

{% if file.options.privacy %}
function sanitizeSearchParams(searchParams: string): string {
  if (!searchParams) return '';

  const params = new URLSearchParams(searchParams);
  const sensitiveParams = ['token', 'key', 'password', 'secret', 'auth', 'session'];

  sensitiveParams.forEach(param => {
    if (params.has(param)) {
      params.set(param, '[REDACTED]');
    }
  });

  return params.toString() ? `?${params.toString()}` : '';
}
{% endif %}

function hashString(input: string): string {
  // Simple hash function for anonymous IDs
  let hash = 0;
  if (input.length === 0) return hash.toString();

  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return Math.abs(hash).toString(36);
}

// Configuration for Next.js middleware
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes that shouldn't be tracked as pageviews)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};

// Cleanup function for graceful shutdown
process.on('SIGTERM', async () => {
  if (postHogMiddleware) {
    await postHogMiddleware.shutdown();
  }
});

// TypeScript types
export interface MiddlewareTrackingOptions {
  distinctId: string;
  skipPaths?: string[];
  {% if file.options.privacy %}
  sanitizeParams?: boolean;
  {% endif %}
}
