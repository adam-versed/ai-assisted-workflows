from __future__ import annotations
import os
from typing import Dict, List
from dataclasses import asdict
from jinja2 import Environment, FileSystemLoader, select_autoescape

try:
    from .models import TaskPlan
except Exception:  # pragma: no cover
    from models import TaskPlan

KEEP_HEADER = """/*
This file was generated by the Skeleton Planner.
Sections between BEGIN-IMPL and END-IMPL are preserved across re-runs.
Traceability and TODOs reference PRD requirements.
*/
"""


def _env(templates_dir: str) -> Environment:
    return Environment(
        loader=FileSystemLoader(templates_dir),
        autoescape=select_autoescape(enabled_extensions=(".jinja",)),
        trim_blocks=True,
        lstrip_blocks=True,
    )


def render_plan(
    plan: TaskPlan, templates_dir: str, out_dir: str, stub_level: int = 1
) -> None:
    env = _env(templates_dir)

    for pf in plan.files:
        # Support primary stack_profile plus any supplemental profiles (e.g., cloudflare-workers, convex)
        candidate_profiles: List[str] = [plan.project.stack_profile] + list(
            getattr(plan.project, "profiles", []) or []
        )
        template_name = _template_for(candidate_profiles, pf.kind)
        template = env.get_template(template_name)
        dest = os.path.join(out_dir, pf.path)
        os.makedirs(os.path.dirname(dest), exist_ok=True)

        content = template.render(
            header=KEEP_HEADER,
            plan=asdict(plan),
            file=asdict(pf),
            stub_level=stub_level,
        )
        with open(dest, "w", encoding="utf-8") as f:
            f.write(content)


def _template_for(stack_profiles: List[str], kind: str) -> str:
    # Map kinds to template files per profile. First match wins, allowing composition.
    mapping: Dict[str, Dict[str, str]] = {
        # App profile
        "nextjs-app-router": {
            "page": "nextjs-app-router/page.jinja",
            "service": "nextjs-app-router/service.jinja",
            "api-route": "nextjs-app-router/api-route.jinja",
            "middleware": "nextjs-app-router/middleware.jinja",
            "turnstile-component": "nextjs-app-router/turnstile-component.jinja",
        },
        # Python app profile
        "python-fastapi": {
            "router": "python-fastapi/router.jinja",
            "service": "python-fastapi/service.jinja",
        },
        # Supplemental profiles
        "cloudflare-workers": {
            "worker-producer": "cloudflare-workers/worker-producer.jinja",
            "worker-consumer": "cloudflare-workers/worker-consumer.jinja",
            "browser-render-client": "cloudflare-workers/browser-render-client.jinja",
            "rate-limit": "cloudflare-workers/rate-limit.jinja",
        },
        "convex": {
            "convex-function": "convex/function.jinja",
            "convex-schema": "convex/schema.jinja",
            "convex-scheduled": "convex/scheduled.jinja",
            "convex-ledgers": "convex/ledgers.jinja",
        },
        "cloudflare-r2": {
            "storage-adapter": "cloudflare-r2/storage-adapter.jinja",
        },
        "analytics-posthog": {
            "analytics-client": "analytics-posthog/client.jinja",
            "analytics-events": "analytics-posthog/events.jinja",
        },
        "nodejs": {
            "node-script": "nodejs/script.jinja",
        },
    }
    for sp in stack_profiles:
        profile = mapping.get(sp, {})
        if kind in profile:
            return profile[kind]
    raise ValueError(f"No template for kind '{kind}' in profiles {stack_profiles}")
