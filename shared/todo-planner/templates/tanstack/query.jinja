// {{ file.path }} - TanStack Query Hook
// Generated from PRD requirements
{% if file.options.mutations %}
// ADVICE: Use useMutation for data modifications with proper error handling and optimistic updates
{% endif %}
{% if file.options.infinite_query %}
// ADVICE: Use useInfiniteQuery for pagination and infinite scrolling patterns
{% endif %}
{% if file.options.suspense %}
// ADVICE: Enable suspense in QueryClient for declarative loading states
{% endif %}

import {
  useQuery,
  useMutation,
  useQueryClient{% if file.options.infinite_query %},
  useInfiniteQuery{% endif %}{% if file.options.suspense %},
  useSuspenseQuery{% endif %}
} from '@tanstack/react-query';
{% if file.options.optimistic_updates %}
import { useOptimistic } from 'react';
{% endif %}

// Query key factory for consistent key management
export const queryKeys = {
  {% for function in functions %}
  {% if 'query' in function.name.lower() %}
  {{ function.name.replace('Query', '').replace('query', '').lower() }}: {
    all: ['{{ function.name.replace('Query', '').replace('query', '').lower() }}'] as const,
    lists: () => [...queryKeys.{{ function.name.replace('Query', '').replace('query', '').lower() }}.all, 'list'] as const,
    list: (filters: Record<string, any>) => [...queryKeys.{{ function.name.replace('Query', '').replace('query', '').lower() }}.lists(), { filters }] as const,
    details: () => [...queryKeys.{{ function.name.replace('Query', '').replace('query', '').lower() }}.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.{{ function.name.replace('Query', '').replace('query', '').lower() }}.details(), id] as const,
  },
  {% endif %}
  {% endfor %}
} as const;

// Data types
interface QueryData {
  // TODO: Define the shape of your query data based on PRD requirements
  id: string;
  title: string;
  description?: string;
  createdAt: string;
  updatedAt: string;
}

interface QueryFilters {
  // TODO: Define filter parameters
  search?: string;
  category?: string;
  status?: 'active' | 'inactive';
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

interface MutationInput {
  // TODO: Define mutation input shape
  title: string;
  description?: string;
}

{% for function in functions %}
{% if 'query' in function.name.lower() and 'mutation' not in function.name.lower() %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export function {{ function.name }}(
  filters?: QueryFilters,
  options?: {
    enabled?: boolean;
    staleTime?: number;
    gcTime?: number; // Previously cacheTime in v4
    refetchOnWindowFocus?: boolean;
    {% if file.options.suspense %}
    suspense?: boolean;
    {% endif %}
  }
) {
  const queryClient = useQueryClient();

  {% if file.options.suspense and 'suspense' in function.name.lower() %}
  return useSuspenseQuery({
  {% else %}
  return useQuery({
  {% endif %}
    queryKey: queryKeys.{{ function.name.replace('Query', '').replace('query', '').lower() }}.list(filters || {}),
    queryFn: async ({ queryKey, signal }) => {
      // Extract filters from query key for type safety
      const [, , { filters: queryFilters }] = queryKey;

      return await fetch{{ function.name.replace('Query', '').replace('query', '') }}Data(queryFilters, { signal });
    },
    staleTime: options?.staleTime ?? 5 * 60 * 1000, // 5 minutes
    gcTime: options?.gcTime ?? 10 * 60 * 1000, // 10 minutes
    enabled: options?.enabled ?? true,
    refetchOnWindowFocus: options?.refetchOnWindowFocus ?? false,
    {% if file.options.error_handling %}
    throwOnError: false, // Handle errors in components
    retry: (failureCount, error) => {
      // Retry logic based on error type
      if (error instanceof Error && error.message.includes('404')) {
        return false; // Don't retry for 404s
      }
      return failureCount < 3;
    },
    {% endif %}
    {% if file.options.background_refetch %}
    refetchOnMount: true,
    refetchOnReconnect: true,
    {% endif %}
  });
}

{% elif 'infinitequery' in function.name.lower() or file.options.infinite_query %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export function {{ function.name.replace('InfiniteQuery', '') or 'useInfinite' }}Query(
  filters?: QueryFilters,
  options?: {
    enabled?: boolean;
    getNextPageParam?: (lastPage: any, allPages: any[]) => any;
  }
) {
  return useInfiniteQuery({
    queryKey: queryKeys.{{ function.name.replace('InfiniteQuery', '').replace('Query', '').replace('query', '').lower() or 'data' }}.list(filters || {}),
    queryFn: async ({ queryKey, pageParam = 1, signal }) => {
      const [, , { filters: queryFilters }] = queryKey;

      return await fetch{{ function.name.replace('InfiniteQuery', '').replace('Query', '').replace('query', '') or 'Data' }}(
        { ...queryFilters, page: pageParam },
        { signal }
      );
    },
    initialPageParam: 1,
    getNextPageParam: options?.getNextPageParam ?? ((lastPage: any) => {
      return lastPage.hasMore ? lastPage.nextPage : undefined;
    }),
    enabled: options?.enabled ?? true,
    staleTime: 5 * 60 * 1000,
    gcTime: 10 * 60 * 1000,
  });
}

{% elif 'mutation' in function.name.lower() %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export function {{ function.name }}(
  options?: {
    onSuccess?: (data: QueryData, variables: MutationInput) => void;
    onError?: (error: Error, variables: MutationInput) => void;
    {% if file.options.optimistic_updates %}
    enableOptimistic?: boolean;
    {% endif %}
  }
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (input: MutationInput): Promise<QueryData> => {
      return await {{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}Data(input);
    },

    {% if file.options.optimistic_updates %}
    onMutate: async (newData: MutationInput) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({
        queryKey: queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.all
      });

      // Snapshot previous value
      const previousData = queryClient.getQueryData(
        queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.lists()
      );

      // Optimistically update
      queryClient.setQueryData(
        queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.lists(),
        (old: any) => {
          if (!old) return [{ ...newData, id: 'temp', createdAt: new Date().toISOString() }];
          return [...old, { ...newData, id: 'temp', createdAt: new Date().toISOString() }];
        }
      );

      return { previousData };
    },

    onError: (error, variables, context) => {
      // Rollback on error
      if (context?.previousData) {
        queryClient.setQueryData(
          queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.lists(),
          context.previousData
        );
      }

      options?.onError?.(error, variables);
    },
    {% endif %}

    onSuccess: (data, variables) => {
      // Invalidate and refetch related queries
      queryClient.invalidateQueries({
        queryKey: queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.all
      });

      // Update specific cache entries if needed
      queryClient.setQueryData(
        queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.detail(data.id),
        data
      );

      options?.onSuccess?.(data, variables);
    },

    onSettled: () => {
      // Always refetch after mutation settles
      queryClient.invalidateQueries({
        queryKey: queryKeys.{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}.all
      });
    },

    {% if file.options.error_handling %}
    throwOnError: false,
    retry: 1,
    {% endif %}
  });
}

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// API functions (implement these based on your backend)
{% for function in functions %}
{% if 'query' in function.name.lower() %}
async function fetch{{ function.name.replace('Query', '').replace('query', '') }}Data(
  filters: QueryFilters = {},
  options: { signal?: AbortSignal } = {}
): Promise<QueryData[]> {
  // TODO: Implement actual API call based on PRD requirements
  const params = new URLSearchParams();

  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && value !== '') {
      params.append(key, String(value));
    }
  });

  const response = await fetch(`/api/{{ function.name.replace('Query', '').replace('query', '').lower() }}?${params}`, {
    signal: options.signal,
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
}

{% elif 'mutation' in function.name.lower() %}
async function {{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}Data(
  input: MutationInput
): Promise<QueryData> {
  // TODO: Implement actual mutation API call
  const response = await fetch('/api/{{ function.name.replace('Mutation', '').replace('mutation', '').lower() }}', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(input),
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
}

{% endif %}
{% endfor %}

// Utility hooks for common patterns
export function useQueryRefresh() {
  const queryClient = useQueryClient();

  return {
    refreshAll: () => {
      queryClient.invalidateQueries();
    },
    refreshQuery: (queryKey: any[]) => {
      queryClient.invalidateQueries({ queryKey });
    },
    clearCache: () => {
      queryClient.clear();
    },
  };
}

{% if file.options.prefetch %}
// Prefetch utilities
export function usePrefetch() {
  const queryClient = useQueryClient();

  return {
    prefetchData: (filters: QueryFilters = {}) => {
      queryClient.prefetchQuery({
        queryKey: queryKeys.data.list(filters),
        queryFn: () => fetchData(filters),
        staleTime: 5 * 60 * 1000,
      });
    },
  };
}
{% endif %}

// TypeScript types export
export type { QueryData, QueryFilters, MutationInput };
export { queryKeys };
