// {{ file.path }} - Convex Mutation Functions
// Generated from PRD requirements
{% if file.options.validation %}
// ADVICE: Validate all input data before database operations
{% endif %}
{% if file.options.multi_tenant %}
// ADVICE: Always include tenantId for SaaS isolation
{% endif %}
{% if file.options.audit_fields %}
// ADVICE: Update audit fields on every mutation
{% endif %}

import { v } from "convex/values";
import { mutation } from "./_generated/server";
{% if file.options.multi_tenant %}
import { getCurrentTenant, verifyTenantAccess } from "./auth";
{% else %}
import { requireAuth } from "./auth";
{% endif %}

{% for function in functions %}
{% if 'create' in function.name|lower or 'update' in function.name|lower or 'delete' in function.name|lower or 'mutation' in function.name|lower %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export const {{ function.name }} = mutation({
  args: {
    {% if 'update' in function.name|lower or 'delete' in function.name|lower %}
    id: v.id("{{ function.name.replace('update', '').replace('delete', '').replace('Update', '').replace('Delete', '')|lower }}s"),
    {% endif %}
    {% if 'create' in function.name|lower or 'update' in function.name|lower %}
    name: v.string(),
    description: v.optional(v.string()),
    status: v.optional(v.string()),
    {% endif %}
    {% if function.signature.params %}
    // TODO: Add specific args based on function signature
    {% for param in function.signature.params %}
    // {{ param }}
    {% endfor %}
    {% endif %}
  },
  handler: async (ctx, args) => {
    {% if file.options.multi_tenant %}
    // REQUIRED: Get current tenant for SaaS isolation
    const tenant = await getCurrentTenant(ctx);
    {% else %}
    // Verify user is authenticated
    await requireAuth(ctx);
    {% endif %}

    {% if file.options.validation %}
    // Validate input data
    if (!args.name || args.name.trim().length === 0) {
      throw new Error("Name is required");
    }
    {% endif %}

    {% if 'create' in function.name|lower %}
    // Create new document
    const now = Date.now();

    const documentId = await ctx.db.insert("{{ function.name.replace('create', '').replace('Create', '')|lower }}s", {
      name: args.name,
      description: args.description,
      status: args.status || "active",
      {% if file.options.multi_tenant %}
      tenantId: tenant._id,
      {% endif %}
      {% if file.options.audit_fields %}
      createdAt: now,
      updatedAt: now,
      {% endif %}
    });

    return documentId;

    {% elif 'update' in function.name|lower %}
    // Update existing document
    const { id, ...updateData } = args;

    {% if file.options.multi_tenant %}
    // Verify document exists and belongs to tenant
    const existingDoc = await ctx.db.get(id);
    await verifyTenantAccess(ctx, existingDoc);
    {% else %}
    // Verify document exists
    const existingDoc = await ctx.db.get(id);
    if (!existingDoc) {
      throw new Error("Document not found");
    }
    {% endif %}

    {% if file.options.audit_fields %}
    updateData.updatedAt = Date.now();
    {% endif %}

    await ctx.db.patch(id, updateData);

    return id;

    {% elif 'delete' in function.name|lower %}
    // Delete document
    const { id } = args;

    {% if file.options.multi_tenant %}
    // Verify document exists and belongs to tenant
    const existingDoc = await ctx.db.get(id);
    await verifyTenantAccess(ctx, existingDoc);
    {% else %}
    // Verify document exists
    const existingDoc = await ctx.db.get(id);
    if (!existingDoc) {
      throw new Error("Document not found");
    }
    {% endif %}

    {% if file.options.soft_delete %}
    // Soft delete - mark as deleted
    await ctx.db.patch(id, {
      deletedAt: Date.now(),
      {% if file.options.audit_fields %}
      updatedAt: Date.now(),
      {% endif %}
    });
    {% else %}
    // Hard delete
    await ctx.db.delete(id);
    {% endif %}

    return { deleted: true };

    {% else %}
    // Custom mutation logic
    const now = Date.now();

    // TODO: Implement specific mutation logic
    const result = await performMutation(args, {% if file.options.multi_tenant %}tenant._id{% else %}null{% endif %});

    return result;
    {% endif %}
  },
});

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

{% set has_mutation_function = false %}
{% for f in functions %}
  {% if 'create' in f.name|lower or 'update' in f.name|lower or 'delete' in f.name|lower %}
    {% set has_mutation_function = true %}
  {% endif %}
{% endfor %}
{% if not functions or not has_mutation_function %}
// Example mutation functions - replace with your actual mutations

// Create a new document
export const createDocument = mutation({
  args: {
    name: v.string(),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    {% if file.options.multi_tenant %}
    const tenant = await getCurrentTenant(ctx);
    {% else %}
    await requireAuth(ctx);
    {% endif %}

    {% if file.options.validation %}
    if (!args.name || args.name.trim().length === 0) {
      throw new Error("Name is required");
    }
    {% endif %}

    const now = Date.now();

    const documentId = await ctx.db.insert("documents", {
      name: args.name,
      description: args.description,
      {% if file.options.multi_tenant %}
      tenantId: tenant._id,
      {% endif %}
      {% if file.options.audit_fields %}
      createdAt: now,
      updatedAt: now,
      {% endif %}
    });

    return documentId;
  },
});

// Update an existing document
export const updateDocument = mutation({
  args: {
    id: v.id("documents"),
    name: v.optional(v.string()),
    description: v.optional(v.string()),
  },
  handler: async (ctx, { id, ...updateData }) => {
    {% if file.options.multi_tenant %}
    const tenant = await getCurrentTenant(ctx);
    const existingDoc = await ctx.db.get(id);
    await verifyTenantAccess(ctx, existingDoc);
    {% else %}
    await requireAuth(ctx);
    const existingDoc = await ctx.db.get(id);
    if (!existingDoc) {
      throw new Error("Document not found");
    }
    {% endif %}

    {% if file.options.validation %}
    if (updateData.name && updateData.name.trim().length === 0) {
      throw new Error("Name cannot be empty");
    }
    {% endif %}

    {% if file.options.audit_fields %}
    updateData.updatedAt = Date.now();
    {% endif %}

    await ctx.db.patch(id, updateData);
    return id;
  },
});

// Delete a document
export const deleteDocument = mutation({
  args: { id: v.id("documents") },
  handler: async (ctx, { id }) => {
    {% if file.options.multi_tenant %}
    const tenant = await getCurrentTenant(ctx);
    const existingDoc = await ctx.db.get(id);
    await verifyTenantAccess(ctx, existingDoc);
    {% else %}
    await requireAuth(ctx);
    const existingDoc = await ctx.db.get(id);
    if (!existingDoc) {
      throw new Error("Document not found");
    }
    {% endif %}

    {% if file.options.soft_delete %}
    await ctx.db.patch(id, {
      deletedAt: Date.now(),
      {% if file.options.audit_fields %}
      updatedAt: Date.now(),
      {% endif %}
    });
    {% else %}
    await ctx.db.delete(id);
    {% endif %}

    return { deleted: true };
  },
});
{% endif %}

// Helper functions
async function performMutation(args: any, tenantId: string | null): Promise<any> {
  // TODO: Implement custom mutation logic
  return { success: true };
}
