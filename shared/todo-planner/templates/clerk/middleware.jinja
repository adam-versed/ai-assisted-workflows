// {{ file.path }} - Clerk Authentication Middleware
// Generated from PRD requirements
{% if file.options.nextjs %}
// ADVICE: Use clerkMiddleware with createRouteMatcher for Next.js App Router protection
{% endif %}
{% if file.options.role_based %}
// ADVICE: Implement role-based access control using Clerk's auth().protect() method
{% endif %}
{% if file.options.api_protection %}
// ADVICE: Protect API routes by checking for valid sessions and tokens
{% endif %}

{% if file.options.nextjs %}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
{% else %}
// For non-Next.js applications, implement custom middleware
import { Clerk } from '@clerk/clerk-js';
{% endif %}

{% if file.options.nextjs %}
// Route matchers for different protection levels
const isPublicRoute = createRouteMatcher([
  '/',
  '/about',
  '/contact',
  '/pricing',
  '/sign-in(.*)',
  '/sign-up(.*)',
  '/sso-callback',
  '/api/webhooks/clerk',
  '/api/health',
  {% if file.options.api_protection %}
  '/api/public(.*)',
  {% endif %}
]);

const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/profile(.*)',
  '/settings(.*)',
  {% if file.options.api_protection %}
  '/api/protected(.*)',
  '/api/user(.*)',
  {% endif %}
]);

{% if file.options.role_based %}
const isAdminRoute = createRouteMatcher([
  '/admin(.*)',
  '/api/admin(.*)',
]);

const isModeratorRoute = createRouteMatcher([
  '/moderation(.*)',
  '/api/moderation(.*)',
]);
{% endif %}

{% if file.options.organizations %}
const isOrganizationRoute = createRouteMatcher([
  '/organization(.*)',
  '/org(.*)',
  '/api/organization(.*)',
]);
{% endif %}

{% for function in functions %}
{% if function.name == 'default' or 'middleware' in function.name.lower() %}
export default clerkMiddleware((auth, request: NextRequest) => {
  // TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}

  const url = request.nextUrl;
  const pathname = url.pathname;

  // Skip middleware for public routes
  if (isPublicRoute(request)) {
    return NextResponse.next();
  }

  // Get authentication context
  const authContext = auth();
  const { userId, sessionId } = authContext;

  // Basic protection for protected routes
  if (isProtectedRoute(request)) {
    authContext.protect();
  }

  {% if file.options.role_based %}
  // Role-based protection
  if (isAdminRoute(request)) {
    authContext.protect({ role: 'admin' });
  }

  if (isModeratorRoute(request)) {
    authContext.protect({
      role: ['admin', 'moderator'] // Allow both admin and moderator roles
    });
  }

  // Permission-based protection (if using custom permissions)
  if (pathname.startsWith('/api/posts') && request.method === 'DELETE') {
    authContext.protect({ permission: 'posts:delete' });
  }

  if (pathname.startsWith('/api/users') && request.method === 'POST') {
    authContext.protect({ permission: 'users:create' });
  }
  {% endif %}

  {% if file.options.organizations %}
  // Organization-based protection
  if (isOrganizationRoute(request)) {
    // Ensure user is part of an organization
    authContext.protect();

    // Additional organization-specific logic can be added here
    const orgSlug = pathname.split('/')[2]; // Extract org slug from URL
    if (orgSlug && orgSlug !== 'select') {
      // TODO: Verify user has access to this specific organization
      // This would typically be done with organization membership checks
    }
  }
  {% endif %}

  {% if file.options.api_protection %}
  // API-specific protection
  if (pathname.startsWith('/api/')) {
    // Skip public API routes
    if (pathname.startsWith('/api/public/')) {
      return NextResponse.next();
    }

    // Protect all other API routes
    if (pathname.startsWith('/api/protected/') || pathname.startsWith('/api/user/')) {
      authContext.protect();
    }

    // Add user context to API requests
    if (userId) {
      const response = NextResponse.next();
      response.headers.set('X-User-Id', userId);
      response.headers.set('X-Session-Id', sessionId || '');
      return response;
    }
  }
  {% endif %}

  // Add security headers
  const response = NextResponse.next();

  {% if file.options.security_headers %}
  // Security headers
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set('X-XSS-Protection', '1; mode=block');

  // Content Security Policy (adjust based on your needs)
  const cspHeader = [
    "default-src 'self'",
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://clerk.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "img-src 'self' blob: data: https://img.clerk.com https://images.clerk.dev",
    "font-src 'self' https://fonts.gstatic.com",
    "connect-src 'self' https://clerk.com https://*.clerk.accounts.dev",
    "frame-src https://clerk.com",
  ].join('; ');

  response.headers.set('Content-Security-Policy', cspHeader);
  {% endif %}

  // Rate limiting headers (if implementing rate limiting)
  {% if file.options.rate_limiting %}
  const clientIp = request.headers.get('x-forwarded-for') ||
                   request.headers.get('x-real-ip') ||
                   'unknown';

  // TODO: Implement actual rate limiting logic
  // This is a placeholder for rate limiting implementation
  response.headers.set('X-RateLimit-Limit', '100');
  response.headers.set('X-RateLimit-Remaining', '99');
  response.headers.set('X-RateLimit-Reset', new Date(Date.now() + 60000).toISOString());
  {% endif %}

  return response;
});

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// Middleware configuration
export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};

{% else %}
// Non-Next.js middleware implementation
export class ClerkAuthMiddleware {
  private clerk: Clerk;

  constructor(publishableKey: string) {
    this.clerk = new Clerk(publishableKey);
  }

  async initialize() {
    await this.clerk.load();
  }

  // Express.js middleware
  expressMiddleware() {
    return async (req: any, res: any, next: any) => {
      try {
        const token = this.extractTokenFromRequest(req);

        if (!token) {
          return res.status(401).json({ error: 'No authentication token provided' });
        }

        // Verify the token (this would need proper implementation)
        const session = await this.verifyToken(token);

        if (!session) {
          return res.status(401).json({ error: 'Invalid authentication token' });
        }

        // Add user context to request
        req.auth = session;
        req.userId = session.userId;

        next();
      } catch (error) {
        console.error('Auth middleware error:', error);
        return res.status(500).json({ error: 'Authentication error' });
      }
    };
  }

  private extractTokenFromRequest(req: any): string | null {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    // Also check cookies
    return req.cookies?.['__session'] || null;
  }

  private async verifyToken(token: string): Promise<any> {
    // TODO: Implement actual token verification with Clerk
    // This is a placeholder
    try {
      // In a real implementation, you would verify the JWT token
      // using Clerk's verification methods
      return { userId: 'user_123', sessionId: 'session_123' };
    } catch {
      return null;
    }
  }
}
{% endif %}

// Utility functions for middleware
export function createAuthRedirect(
  destination: string,
  returnUrl?: string
): NextResponse {
  const url = new URL(destination, 'http://localhost:3000');
  if (returnUrl) {
    url.searchParams.set('return_url', returnUrl);
  }
  return NextResponse.redirect(url);
}

export function createUnauthorizedResponse(
  message: string = 'Unauthorized'
): NextResponse {
  return new NextResponse(
    JSON.stringify({ error: message }),
    {
      status: 401,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}

export function createForbiddenResponse(
  message: string = 'Forbidden'
): NextResponse {
  return new NextResponse(
    JSON.stringify({ error: message }),
    {
      status: 403,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}

{% if file.options.rate_limiting %}
// Rate limiting utilities
interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  message?: string;
}

const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

export function rateLimit(config: RateLimitConfig) {
  return (request: NextRequest): NextResponse | null => {
    const clientIp = request.headers.get('x-forwarded-for') ||
                     request.headers.get('x-real-ip') ||
                     'unknown';

    const key = `${clientIp}:${request.nextUrl.pathname}`;
    const now = Date.now();
    const windowStart = now - config.windowMs;

    // Clean up old entries
    for (const [k, v] of rateLimitStore.entries()) {
      if (v.resetTime < now) {
        rateLimitStore.delete(k);
      }
    }

    // Get current count
    const current = rateLimitStore.get(key) || { count: 0, resetTime: now + config.windowMs };

    if (current.count >= config.maxRequests) {
      return new NextResponse(
        JSON.stringify({
          error: config.message || 'Too many requests'
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'X-RateLimit-Limit': config.maxRequests.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': current.resetTime.toString(),
          },
        }
      );
    }

    // Increment count
    current.count++;
    rateLimitStore.set(key, current);

    return null; // Continue processing
  };
}
{% endif %}

// TypeScript types
export interface AuthContext {
  userId: string | null;
  sessionId: string | null;
  orgId?: string | null;
  role?: string;
  permissions?: string[];
}

export interface MiddlewareConfig {
  publicRoutes: string[];
  protectedRoutes: string[];
  {% if file.options.role_based %}
  adminRoutes?: string[];
  moderatorRoutes?: string[];
  {% endif %}
  {% if file.options.organizations %}
  organizationRoutes?: string[];
  {% endif %}
}
