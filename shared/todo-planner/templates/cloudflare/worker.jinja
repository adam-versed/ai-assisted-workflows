// {{ file.path }} - Cloudflare Worker
// Generated from PRD requirements
{% if file.options.retry %}
// ADVICE: Implement exponential backoff for transient errors
{% endif %}
{% if file.options.dlq %}
// ADVICE: Configure dead letter queue for failed messages
{% endif %}
{% if file.options.metrics %}
// ADVICE: Add observability with metrics and logging
{% endif %}

export default {
  async fetch(request, env, ctx) {
    try {
      // TODO: Handle HTTP requests

      {% if file.options.metrics %}
      // Emit basic metrics (start/end/duration/outcome)
      const startTime = Date.now();
      {% endif %}

      const url = new URL(request.url);

      // Main request processing
      const response = await processRequest(request, env, ctx);

      {% if file.options.metrics %}
      const duration = Date.now() - startTime;
      console.log(`Request processed in ${duration}ms`);
      {% endif %}

      return response;
    } catch (error) {
      console.error('Worker error:', error);

      {% if file.options.retry %}
      // Check if error is retryable
      if (error.retriable) {
        // Return appropriate status for retry
        return new Response('Temporary error', { status: 503 });
      }
      {% endif %}

      return new Response('Internal Server Error', { status: 500 });
    }
  },

  {% if file.options.queue or 'queue' in [f.name.lower() for f in functions] %}
  async queue(batch, env, ctx) {
    // TODO: Process queue messages
    // ADVICE: Process messages idempotently; dedupe by correlation key
    // ADVICE: Bound concurrency via ctx.waitUntil and reasonable timeouts

    for (const message of batch.messages) {
      try {
        {% if file.options.retry %}
        // Use exponential backoff on transient errors
        {% endif %}

        await processMessage(message, env, ctx);

        {% if file.options.dlq %}
        // Message processed successfully
        {% endif %}
      } catch (error) {
        {% if file.options.dlq %}
        // On permanent failure, emit to DLQ with reason
        if (error.permanent) {
          await sendToDLQ(message, error, env);
        }
        {% endif %}

        message.retry();
      }
    }
  }
  {% endif %}
};

{% for function in functions %}
{% if function.name not in ['fetch', 'queue'] %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// Helper functions
async function processRequest(request, env, ctx) {
  // TODO: Implement main request logic
  return new Response('Hello World');
}

{% if file.options.queue or 'queue' in [f.name.lower() for f in functions] %}
async function processMessage(message, env, ctx) {
  // TODO: Implement message processing logic
  throw new Error("Message processing not implemented");
}

{% if file.options.dlq %}
async function sendToDLQ(message, error, env) {
  // TODO: Send failed message to dead letter queue
  console.error('Sending to DLQ:', { message: message.id, error: error.message });
}
{% endif %}
{% endif %}
