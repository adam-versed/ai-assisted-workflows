// {{ file.path }} - PostHog Event Definitions and Tracking
// Generated from PRD requirements
{% if file.options.privacy %}
// ADVICE: Event constants help maintain consistent naming and avoid PII in event names
{% endif %}
{% if file.options.correlation %}
// ADVICE: Use consistent event naming for user journey tracking and funnel analysis
{% endif %}

import { useAnalytics } from './provider';

{% for function in functions %}
{% if 'events' in function.name.lower() %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export const {{ function.name.replace('Events', '').replace('Analytics', '') or 'AppEvents' }} = {
  // User lifecycle events
  USER_SIGNED_UP: 'user signed up',
  USER_LOGGED_IN: 'user logged in',
  USER_LOGGED_OUT: 'user logged out',
  USER_PROFILE_UPDATED: 'user profile updated',

  // Feature interaction events
  FEATURE_VIEWED: 'feature viewed',
  BUTTON_CLICKED: 'button clicked',
  FORM_SUBMITTED: 'form submitted',
  SEARCH_PERFORMED: 'search performed',

  // Business conversion events
  TRIAL_STARTED: 'trial started',
  SUBSCRIPTION_CREATED: 'subscription created',
  PAYMENT_COMPLETED: 'payment completed',
  UPGRADE_INITIATED: 'upgrade initiated',

  // Error and support events
  ERROR_ENCOUNTERED: 'error encountered',
  SUPPORT_CONTACTED: 'support contacted',
  FEEDBACK_SUBMITTED: 'feedback submitted',

  // TODO: Add domain-specific events based on PRD requirements
} as const;

export type EventName = typeof {{ function.name.replace('Events', '').replace('Analytics', '') or 'AppEvents' }}[keyof typeof {{ function.name.replace('Events', '').replace('Analytics', '') or 'AppEvents' }}];

{% elif 'track' in function.name.lower() or 'capture' in function.name.lower() %}
// TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}
export function {{ function.name }}(
  eventName: EventName | string,
  properties?: Record<string, any>,
  options?: {
    {% if file.options.correlation %}
    correlationId?: string;
    {% endif %}
    timestamp?: string;
    userId?: string;
  }
) {
  const { track, isLoaded } = useAnalytics();

  if (!isLoaded) {
    console.warn('PostHog not loaded, event not tracked:', eventName);
    return;
  }

  const eventProperties = {
    ...properties,
    {% if file.options.correlation %}
    correlation_id: options?.correlationId || generateCorrelationId(),
    {% endif %}
    timestamp: options?.timestamp || new Date().toISOString(),
    page_url: typeof window !== 'undefined' ? window.location.href : undefined,
    user_agent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,
  };

  {% if file.options.privacy %}
  // Remove any potential PII from properties
  const sanitizedProperties = sanitizeEventData(eventProperties);
  track(eventName, sanitizedProperties);
  {% else %}
  track(eventName, eventProperties);
  {% endif %}
}

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// PostHog-specific tracking functions using their recommended patterns
export function trackPageView(pageName: string, properties?: Record<string, any>) {
  const { track, isLoaded } = useAnalytics();

  if (isLoaded) {
    track('$pageview', {
      page_name: pageName,
      ...properties,
    });
  }
}

export function trackUserAction(action: string, target: string, properties?: Record<string, any>) {
  const { track, isLoaded } = useAnalytics();

  if (isLoaded) {
    // PostHog recommends [object] [verb] format
    track(`${target} ${action}`, {
      action_type: action,
      target_element: target,
      ...properties,
    });
  }
}

export function trackConversionEvent(
  conversionType: 'trial' | 'purchase' | 'subscription' | 'upgrade',
  properties?: Record<string, any>
) {
  const { track, isLoaded } = useAnalytics();

  if (isLoaded) {
    track(`${conversionType} completed`, {
      conversion_type: conversionType,
      ...properties,
    });
  }
}

export function identifyUser(
  userId: string,
  userProperties?: Record<string, any>
) {
  const { identify, isLoaded } = useAnalytics();

  if (isLoaded) {
    {% if file.options.privacy %}
    // Only include safe user properties
    const safeProperties = sanitizeUserData(userProperties || {});
    identify(userId, safeProperties);
    {% else %}
    identify(userId, userProperties);
    {% endif %}
  }
}

export function aliasUser(alias: string) {
  const { alias: postHogAlias, isLoaded } = useAnalytics();

  if (isLoaded) {
    postHogAlias(alias);
  }
}

{% if file.options.correlation %}
// Correlation ID generation for user journey tracking
function generateCorrelationId(): string {
  return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

// Session-based correlation ID (persists across page loads)
export function getSessionCorrelationId(): string {
  if (typeof window === 'undefined') return generateCorrelationId();

  let sessionId = sessionStorage.getItem('posthog_correlation_id');
  if (!sessionId) {
    sessionId = generateCorrelationId();
    sessionStorage.setItem('posthog_correlation_id', sessionId);
  }
  return sessionId;
}
{% endif %}

{% if file.options.privacy %}
// Privacy-focused data sanitization for PostHog
function sanitizeEventData(data: Record<string, any>): Record<string, any> {
  const piiFields = [
    'email', 'phone', 'name', 'address', 'ssn', 'password',
    'credit_card', 'bank_account', 'social_security'
  ];

  const sanitized = { ...data };

  piiFields.forEach(field => {
    if (field in sanitized) {
      delete sanitized[field];
    }
  });

  // Remove nested PII
  Object.keys(sanitized).forEach(key => {
    if (typeof sanitized[key] === 'object' && sanitized[key] !== null) {
      sanitized[key] = sanitizeEventData(sanitized[key]);
    }
  });

  return sanitized;
}

function sanitizeUserData(userData: Record<string, any>): Record<string, any> {
  // Only include safe user properties for PostHog person profiles
  const allowedUserFields = [
    'plan', 'subscription_tier', 'role', 'created_at', 'last_seen',
    'feature_flags', 'experiment_groups', 'subscription_status'
  ];

  const sanitized: Record<string, any> = {};

  allowedUserFields.forEach(field => {
    if (field in userData) {
      sanitized[field] = userData[field];
    }
  });

  return sanitized;
}
{% endif %}

// React hook for tracking component interactions
export function useEventTracking() {
  const { track, isLoaded } = useAnalytics();

  return {
    trackClick: (element: string, properties?: Record<string, any>) => {
      if (isLoaded) {
        track('button clicked', {
          element,
          ...properties,
        });
      }
    },

    trackFormSubmit: (formName: string, properties?: Record<string, any>) => {
      if (isLoaded) {
        track('form submitted', {
          form_name: formName,
          ...properties,
        });
      }
    },

    trackError: (error: Error, context?: Record<string, any>) => {
      if (isLoaded) {
        track('error encountered', {
          error_message: error.message,
          error_stack: error.stack?.slice(0, 500), // Truncate for privacy
          ...context,
        });
      }
    },

    isLoaded,
  };
}

// TypeScript types
export interface TrackingOptions {
  {% if file.options.correlation %}
  correlationId?: string;
  {% endif %}
  timestamp?: string;
  userId?: string;
}

export interface ConversionProperties {
  revenue?: number;
  currency?: string;
  plan_name?: string;
  billing_cycle?: 'monthly' | 'yearly';
}

export interface UserProperties {
  plan?: string;
  subscription_tier?: string;
  role?: string;
  created_at?: string;
  last_seen?: string;
}
