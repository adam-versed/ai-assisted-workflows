// {{ file.path }} - Mongoose Database Client
// Generated from PRD requirements
{% if file.options.connection_pooling %}
// ADVICE: Configure MongoDB connection pooling
{% endif %}
{% if file.options.transactions %}
// ADVICE: Use MongoDB transactions for data consistency
{% endif %}
{% if file.options.migrations %}
// ADVICE: Use migrate-mongo for schema changes
{% endif %}

import mongoose from 'mongoose';

// Import your Mongoose models
// import { Document, User, etc. } from './models';

{% if file.options.connection_pooling %}
// MongoDB connection with connection pooling
const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI!, {
      maxPoolSize: 10, // Maintain up to 10 socket connections
      serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
      bufferMaxEntries: 0, // Disable mongoose buffering
      bufferCommands: false, // Disable mongoose buffering
    });

    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};
{% else %}
// Basic MongoDB connection
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI!);
    console.log('MongoDB Connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};
{% endif %}

// Initialize connection
connectDB();

{% for function in functions %}
export async function {{ function.name }}({% if function.signature.params %}{{ function.signature.params | join(', ') }}{% endif %}): Promise<{{ function.signature.return_type or 'any' }}> {
  // TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}

  {% if file.options.transactions %}
  // Execute within MongoDB transaction
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
  {% endif %}

    {% if 'create' in function.name.lower() or 'insert' in function.name.lower() %}
    // Create new document using Mongoose
    const result = new Model({
      name: data.name,
      description: data.description,
      // TODO: Map function parameters to Mongoose model fields
    });

    await result.save({% if file.options.transactions %}{ session }{% endif %});

    {% elif 'update' in function.name.lower() %}
    // Update existing document using Mongoose
    const result = await Model.findByIdAndUpdate(
      id,
      {
        name: data.name,
        description: data.description,
        updatedAt: new Date(),
      },
      {
        new: true,
        runValidators: true{% if file.options.transactions %},
        session{% endif %}
      }
    );

    {% elif 'delete' in function.name.lower() %}
    // Delete document using Mongoose
    {% if file.options.soft_delete %}
    const result = await Model.findByIdAndUpdate(
      id,
      { deletedAt: new Date() },
      { new: true{% if file.options.transactions %}, session{% endif %} }
    );
    {% else %}
    const result = await Model.findByIdAndDelete(id{% if file.options.transactions %}, { session }{% endif %});
    {% endif %}

    {% elif 'get' in function.name.lower() or 'find' in function.name.lower() or 'select' in function.name.lower() %}
    // Query documents using Mongoose
    {% if 'get' in function.name.lower() %}
    const result = await Model.findById(id){% if file.options.soft_delete %}.where({ deletedAt: { $exists: false } }){% endif %}{% if file.options.transactions %}.session(session){% endif %};
    {% else %}
    const result = await Model.find({% if file.options.soft_delete %}{ deletedAt: { $exists: false } }{% endif %})
      .limit(100)
      .sort({ createdAt: -1 }){% if file.options.transactions %}
      .session(session){% endif %};
    {% endif %}

    {% else %}
    // Custom database operation using Mongoose
    const result = await performMongooseOperation({% if function.signature.params %}{{ function.signature.params[0].split(':')[0] if function.signature.params }}{% endif %}{% if file.options.transactions %}, session{% endif %});
    {% endif %}

    {% if file.options.transactions %}
    await session.commitTransaction();
    {% endif %}
    return result;

  {% if file.options.transactions %}
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
  {% endif %}
}

{% endfor %}

// Helper functions
async function performMongooseOperation(data?: any, session?: mongoose.ClientSession): Promise<any> {
  // TODO: Implement custom Mongoose database logic
  throw new Error("Mongoose operation not implemented");
}

{% if file.options.migrations %}
// Migration helpers for MongoDB
export async function runMigrations() {
  // TODO: Implement MongoDB migrations
  // Use migrate-mongo for schema migrations
  console.log("Running MongoDB migrations...");
}

export async function createMigration(name: string) {
  // TODO: Create migration file
  // Use: npx migrate-mongo create migration_name
  console.log(`Creating MongoDB migration: ${name}`);
}
{% endif %}

// Connection management
export async function disconnectDB() {
  await mongoose.disconnect();
  console.log('MongoDB Disconnected');
}

// Export mongoose for direct access if needed
export { mongoose };
