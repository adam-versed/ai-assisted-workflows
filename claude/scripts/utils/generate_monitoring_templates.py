#!/usr/bin/env python3
"""
Monitoring configuration template generator.
Creates monitoring files based on project analysis and detected patterns.
"""

import os
import sys
import argparse
import json
import tempfile
from pathlib import Path
from datetime import datetime

def generate_makefile_monitoring(project_info, output_dir):
    """Generate Makefile with monitoring targets."""
    makefile_content = f"""# Development Monitoring Makefile
# Generated by setup-dev-monitoring on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project: {project_info.get('name', 'Unknown')}
# Type: {', '.join(project_info.get('types', []))}

# WARNING: Claude should NEVER run 'make dev' or 'make start' commands
# These are USER-ONLY commands for starting development services

.PHONY: help dev stop status logs tail-logs health check-deps monitor clean

# Default target
help:
\t@echo "Available targets:"
\t@echo "  dev          - Start all development services (USER ONLY)"
\t@echo "  stop         - Stop all development services (USER ONLY)"
\t@echo "  status       - Show service status"
\t@echo "  logs         - Show aggregated logs"
\t@echo "  tail-logs    - Follow logs in real-time"
\t@echo "  health       - Check service health"
\t@echo "  monitor      - Show system monitoring dashboard"
\t@echo "  check-deps   - Verify monitoring dependencies"
\t@echo "  clean        - Clean logs and temporary files"

# USER-ONLY COMMANDS - Claude should never execute these
dev:
\t@echo "Starting development services..."
"""
    
    # Add service-specific dev commands based on project type
    if "nodejs" in project_info.get("types", []):
        makefile_content += """\t@if [ -f "package.json" ]; then \\
\t\techo "Starting Node.js services..."; \\
\t\tpm2 start ecosystem.config.js 2>/dev/null || npm run dev & echo $$! > .dev.pid; \\
\tfi
"""
    
    if "python" in project_info.get("types", []):
        makefile_content += """\t@if [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then \\
\t\techo "Starting Python services..."; \\
\t\tpython app.py & echo $$! > .python.pid; \\
\tfi
"""
    
    if "docker" in project_info.get("types", []):
        makefile_content += """\t@if [ -f "docker-compose.yml" ]; then \\
\t\techo "Starting Docker services..."; \\
\t\tdocker-compose up -d; \\
\tfi
"""
    
    makefile_content += """\t@echo "Services started. Use 'make tail-logs' to monitor output."

stop:
\t@echo "Stopping development services..."
"""
    
    # Add service-specific stop commands
    if "nodejs" in project_info.get("types", []):
        makefile_content += """\t@pm2 stop all 2>/dev/null || true
\t@if [ -f ".dev.pid" ]; then kill `cat .dev.pid` 2>/dev/null || true; rm .dev.pid; fi
"""
    
    if "python" in project_info.get("types", []):
        makefile_content += """\t@if [ -f ".python.pid" ]; then kill `cat .python.pid` 2>/dev/null || true; rm .python.pid; fi
"""
    
    if "docker" in project_info.get("types", []):
        makefile_content += """\t@if [ -f "docker-compose.yml" ]; then docker-compose down; fi
"""
    
    # Claude-accessible monitoring commands
    makefile_content += """
# CLAUDE-ACCESSIBLE COMMANDS - Safe for AI to execute
status:
\t@echo "=== Service Status ==="
"""
    
    if "nodejs" in project_info.get("types", []):
        makefile_content += """\t@pm2 status 2>/dev/null || echo "PM2 not running"
"""
    
    if "docker" in project_info.get("types", []):
        makefile_content += """\t@if [ -f "docker-compose.yml" ]; then docker-compose ps; fi
"""
    
    makefile_content += """\t@echo "=== System Resources ==="
\t@ps aux | head -1
\t@ps aux | grep -E "(node|python|docker)" | grep -v grep || echo "No monitored processes found"

logs:
\t@echo "=== Recent Logs ==="
\t@if [ -f "dev.log" ]; then tail -100 dev.log; else echo "No dev.log found"; fi

tail-logs:
\t@echo "=== Following Logs (Ctrl+C to exit) ==="
\t@if [ -f "dev.log" ]; then tail -f dev.log; else echo "No dev.log found. Start services first."; fi

health:
\t@echo "=== Health Check ==="
"""
    
    # Add health checks based on project services
    for service in project_info.get("services", []):
        port = service.get("port", 3000)
        name = service.get("name", "service")
        makefile_content += f"""\t@curl -sf http://localhost:{port}/health 2>/dev/null && echo "{name}: ✓ Healthy" || echo "{name}: ✗ Unhealthy"
"""
    
    makefile_content += """
monitor:
\t@echo "=== System Monitor ==="
\t@echo "Memory Usage:"
\t@free -h 2>/dev/null || vm_stat | head -5
\t@echo "Disk Usage:"
\t@df -h . | tail -1
\t@echo "CPU Usage:"
\t@top -l 1 -n 5 | head -15 2>/dev/null || top -bn1 | head -15

check-deps:
\t@echo "=== Dependency Check ==="
\t@python3 claude/scripts/utils/check_system_dependencies.py --monitoring || echo "Dependency check script not found"

clean:
\t@echo "Cleaning logs and temporary files..."
\t@rm -f dev.log *.pid
\t@echo "Clean complete"
"""
    
    makefile_path = Path(output_dir) / "Makefile"
    with open(makefile_path, "w") as f:
        f.write(makefile_content)
    
    return str(makefile_path)

def generate_pm2_ecosystem(project_info, output_dir):
    """Generate PM2 ecosystem file for Node.js projects."""
    if "nodejs" not in project_info.get("types", []):
        return None
    
    ecosystem = {
        "apps": []
    }
    
    for service in project_info.get("services", []):
        app_config = {
            "name": service.get("name", "app"),
            "script": service.get("script", "npm"),
            "args": service.get("args", "start"),
            "cwd": service.get("cwd", "."),
            "env": {
                "NODE_ENV": "development",
                "PORT": service.get("port", 3000)
            },
            "log_file": "dev.log",
            "time": True,
            "merge_logs": True,
            "max_restarts": 3,
            "min_uptime": "5s"
        }
        ecosystem["apps"].append(app_config)
    
    # If no services specified, create default
    if not ecosystem["apps"]:
        ecosystem["apps"] = [{
            "name": "app",
            "script": "npm",
            "args": "start",
            "env": {"NODE_ENV": "development", "PORT": 3000},
            "log_file": "dev.log",
            "time": True,
            "merge_logs": True
        }]
    
    ecosystem_path = Path(output_dir) / "ecosystem.config.js"
    with open(ecosystem_path, "w") as f:
        f.write(f"module.exports = {json.dumps(ecosystem, indent=2)}")
    
    return str(ecosystem_path)

def generate_docker_compose_monitoring(project_info, output_dir):
    """Generate or enhance docker-compose.yml with monitoring."""
    compose_content = f"""# Docker Compose with Monitoring
# Generated by setup-dev-monitoring on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
version: '3.8'

services:
"""
    
    # Add services based on project analysis
    for service in project_info.get("services", []):
        service_name = service.get("name", "app")
        compose_content += f"""  {service_name}:
    build: {service.get("build", ".")}
    ports:
      - "{service.get("port", 3000)}:{service.get("port", 3000)}"
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
      - /app/node_modules
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:{service.get("port", 3000)}/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

"""
    
    # Add monitoring services if requested
    if project_info.get("include_monitoring_services", False):
        compose_content += """  # Monitoring Services
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-storage:/var/lib/grafana

volumes:
  grafana-storage:
"""
    
    compose_path = Path(output_dir) / "docker-compose.monitoring.yml"
    with open(compose_path, "w") as f:
        f.write(compose_content)
    
    return str(compose_path)

def generate_claude_md(project_info, output_dir):
    """Generate or update .claude/CLAUDE.md with monitoring information."""
    claude_dir = Path(output_dir) / ".claude"
    claude_dir.mkdir(exist_ok=True)
    
    claude_content = f"""# Development Monitoring Configuration
Generated by setup-dev-monitoring on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Project Information
- **Name**: {project_info.get('name', 'Unknown')}
- **Types**: {', '.join(project_info.get('types', []))}
- **Services**: {len(project_info.get('services', []))}

## Service Management Commands

### USER-ONLY Commands (Claude MUST NOT Execute)
```bash
make dev          # Start all development services
make stop         # Stop all development services
npm run dev       # Start Node.js development server
docker-compose up # Start containerized services
```

### Claude-Accessible Monitoring Commands
```bash
make status       # Check service status
make logs         # View recent logs
make tail-logs    # Follow logs in real-time
make health       # Check service health endpoints
make monitor      # Show system resource usage
make check-deps   # Verify monitoring dependencies
make clean        # Clean logs and temporary files
```

## Log Files and Monitoring
- **Main log file**: `dev.log` (aggregated service logs)
- **Service status**: Available via `make status`
- **Health checks**: Available via `make health`
- **System monitoring**: Available via `make monitor`

## Service Endpoints
"""
    
    for service in project_info.get("services", []):
        name = service.get("name", "service")
        port = service.get("port", 3000)
        claude_content += f"- **{name}**: http://localhost:{port}\n"
        claude_content += f"  - Health: http://localhost:{port}/health\n"
    
    claude_content += f"""
## Monitoring Tools Installed
{', '.join(project_info.get('monitoring_tools', ['htop', 'curl', 'jq']))}

## Development Workflow
1. User runs `make dev` to start services
2. Claude can monitor via `make status`, `make logs`, `make health`
3. User stops services with `make stop`
4. Claude can clean up with `make clean`

## Safety Rules
- Claude MUST NEVER execute service start/stop commands
- All service management is USER-CONTROLLED
- Claude can only use monitoring and status commands
- Log files provide complete service visibility
"""
    
    claude_path = claude_dir / "CLAUDE.md"
    with open(claude_path, "w") as f:
        f.write(claude_content)
    
    return str(claude_path)

def generate_monitoring_config(project_info, output_dir):
    """Generate monitoring configuration files."""
    config_content = f"""# Monitoring Configuration
# Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

[monitoring]
log_file = dev.log
log_level = info
max_log_size = 10MB
log_rotation = 3

[health_checks]
enabled = true
interval = 30
timeout = 10
"""
    
    for service in project_info.get("services", []):
        config_content += f"""
[service.{service.get('name', 'app')}]
port = {service.get('port', 3000)}
health_endpoint = /health
"""
    
    config_path = Path(output_dir) / "monitoring.conf"
    with open(config_path, "w") as f:
        f.write(config_content)
    
    return str(config_path)

def main():
    parser = argparse.ArgumentParser(description="Generate monitoring configuration templates")
    parser.add_argument("--project-type", nargs="+", required=True,
                       help="Project types: nodejs, python, docker, etc.")
    parser.add_argument("--architecture", help="Architecture pattern: monorepo, single-repo, microservices")
    parser.add_argument("--services", help="JSON string of service configurations")
    parser.add_argument("--output-dir", default=".", help="Output directory")
    parser.add_argument("--name", help="Project name")
    parser.add_argument("--include-monitoring-services", action="store_true",
                       help="Include external monitoring services (Prometheus, Grafana)")
    parser.add_argument("--json", action="store_true", help="Output results as JSON")
    
    args = parser.parse_args()
    
    # Parse service configurations
    services = []
    if args.services:
        try:
            services = json.loads(args.services)
        except json.JSONDecodeError:
            print("Error: Invalid JSON in --services argument")
            return 1
    
    # Build project info
    project_info = {
        "name": args.name or "Unknown Project",
        "types": args.project_type,
        "architecture": args.architecture,
        "services": services,
        "include_monitoring_services": args.include_monitoring_services,
        "monitoring_tools": ["htop", "curl", "jq", "watchexec"]
    }
    
    # Generate templates
    generated_files = {}
    
    try:
        # Always generate Makefile
        generated_files["makefile"] = generate_makefile_monitoring(project_info, args.output_dir)
        
        # Generate PM2 ecosystem for Node.js projects
        if "nodejs" in args.project_type:
            ecosystem_file = generate_pm2_ecosystem(project_info, args.output_dir)
            if ecosystem_file:
                generated_files["pm2_ecosystem"] = ecosystem_file
        
        # Generate Docker Compose if Docker detected
        if "docker" in args.project_type:
            generated_files["docker_compose"] = generate_docker_compose_monitoring(project_info, args.output_dir)
        
        # Always generate Claude.md
        generated_files["claude_md"] = generate_claude_md(project_info, args.output_dir)
        
        # Generate monitoring config
        generated_files["monitoring_config"] = generate_monitoring_config(project_info, args.output_dir)
        
        if args.json:
            result = {
                "success": True,
                "generated_files": generated_files,
                "project_info": project_info
            }
            print(json.dumps(result, indent=2))
        else:
            print("Generated monitoring templates:")
            for file_type, file_path in generated_files.items():
                print(f"  {file_type}: {file_path}")
        
        return 0
        
    except Exception as e:
        if args.json:
            result = {
                "success": False,
                "error": str(e),
                "generated_files": generated_files
            }
            print(json.dumps(result, indent=2))
        else:
            print(f"Error generating templates: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())