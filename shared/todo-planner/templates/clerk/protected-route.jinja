// {{ file.path }} - Clerk Protected Route Component
// Generated from PRD requirements
{% if file.options.role_based %}
// ADVICE: Use role-based access control with Clerk's organization features
{% endif %}
{% if file.options.redirect %}
// ADVICE: Configure custom redirect URLs for unauthenticated users
{% endif %}
{% if file.options.loading %}
// ADVICE: Show loading states while authentication is being verified
{% endif %}

import React from 'react';
{% if file.options.nextjs %}
import { useAuth, useUser, RedirectToSignIn } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';
{% else %}
import { useAuth, useUser, RedirectToSignIn } from '@clerk/clerk-react';
{% endif %}
{% if file.options.organizations %}
import { useOrganization } from '@clerk/clerk-react';
{% endif %}

// Protected route configuration
interface ProtectedRouteConfig {
  // Authentication requirements
  requireAuth?: boolean;

  {% if file.options.role_based %}
  // Role-based access control
  allowedRoles?: string[];
  requiredPermissions?: string[];
  {% endif %}

  {% if file.options.organizations %}
  // Organization requirements
  requireOrganization?: boolean;
  allowedOrganizations?: string[];
  {% endif %}

  // Redirect configuration
  redirectTo?: string;
  redirectToSignIn?: boolean;

  // Loading and error handling
  loadingComponent?: React.ComponentType;
  unauthorizedComponent?: React.ComponentType<{ reason: string }>;

  // Custom validation
  customValidator?: (user: any, auth: any) => boolean | string;
}

interface Props {
  children: React.ReactNode;
  config?: ProtectedRouteConfig;
  fallback?: React.ReactNode;
  className?: string;
}

// Default configuration
const defaultConfig: ProtectedRouteConfig = {
  requireAuth: true,
  redirectToSignIn: true,
  {% if file.options.role_based %}
  allowedRoles: [],
  requiredPermissions: [],
  {% endif %}
  {% if file.options.organizations %}
  requireOrganization: false,
  allowedOrganizations: [],
  {% endif %}
};

{% for function in functions %}
{% if function.name == 'default' or 'protected' in function.name.lower() %}
export default function {{ function.name.replace('default', file.path.split('/')[-1].replace('.tsx', '').replace('.jsx', '')) }}({
  children,
  config = {},
  fallback,
  className = ''
}: Props) {
  // TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}

  const mergedConfig = { ...defaultConfig, ...config };
  const { isLoaded, isSignedIn, userId, getToken } = useAuth();
  const { user } = useUser();
  {% if file.options.organizations %}
  const { organization, membership } = useOrganization();
  {% endif %}
  {% if file.options.nextjs %}
  const router = useRouter();
  {% endif %}

  // Loading state
  if (!isLoaded) {
    if (mergedConfig.loadingComponent) {
      const LoadingComponent = mergedConfig.loadingComponent;
      return <LoadingComponent />;
    }

    return (
      <div className={`protected-route-loading ${className}`}>
        <div className="loading-container">
          <div className="loading-spinner" />
          <p>Verifying authentication...</p>
        </div>
      </div>
    );
  }

  // Authentication check
  if (mergedConfig.requireAuth && !isSignedIn) {
    if (mergedConfig.redirectToSignIn) {
      return <RedirectToSignIn redirectUrl={mergedConfig.redirectTo} />;
    }

    if (mergedConfig.redirectTo) {
      {% if file.options.nextjs %}
      router.push(mergedConfig.redirectTo);
      return null;
      {% else %}
      window.location.href = mergedConfig.redirectTo;
      return null;
      {% endif %}
    }

    if (fallback) {
      return <>{fallback}</>;
    }

    return (
      <div className={`protected-route-unauthorized ${className}`}>
        <div className="unauthorized-container">
          <h2>Authentication Required</h2>
          <p>You must be signed in to access this page.</p>
          <button
            onClick={() => {% if file.options.nextjs %}router.push('/sign-in'){% else %}window.location.href = '/sign-in'{% endif %}}
            className="sign-in-button"
          >
            Sign In
          </button>
        </div>
      </div>
    );
  }

  {% if file.options.role_based %}
  // Role-based access control
  if (mergedConfig.allowedRoles && mergedConfig.allowedRoles.length > 0) {
    const userRoles = user?.publicMetadata?.roles as string[] || [];
    const hasValidRole = mergedConfig.allowedRoles.some(role =>
      userRoles.includes(role)
    );

    if (!hasValidRole) {
      if (mergedConfig.unauthorizedComponent) {
        const UnauthorizedComponent = mergedConfig.unauthorizedComponent;
        return <UnauthorizedComponent reason="insufficient_role" />;
      }

      return (
        <div className={`protected-route-forbidden ${className}`}>
          <div className="forbidden-container">
            <h2>Access Denied</h2>
            <p>You don't have the required role to access this page.</p>
            <p>Required roles: {mergedConfig.allowedRoles.join(', ')}</p>
          </div>
        </div>
      );
    }
  }

  // Permission-based access control
  if (mergedConfig.requiredPermissions && mergedConfig.requiredPermissions.length > 0) {
    const userPermissions = user?.publicMetadata?.permissions as string[] || [];
    const hasRequiredPermissions = mergedConfig.requiredPermissions.every(permission =>
      userPermissions.includes(permission)
    );

    if (!hasRequiredPermissions) {
      if (mergedConfig.unauthorizedComponent) {
        const UnauthorizedComponent = mergedConfig.unauthorizedComponent;
        return <UnauthorizedComponent reason="insufficient_permissions" />;
      }

      return (
        <div className={`protected-route-forbidden ${className}`}>
          <div className="forbidden-container">
            <h2>Access Denied</h2>
            <p>You don't have the required permissions to access this page.</p>
            <p>Required permissions: {mergedConfig.requiredPermissions.join(', ')}</p>
          </div>
        </div>
      );
    }
  }
  {% endif %}

  {% if file.options.organizations %}
  // Organization requirements
  if (mergedConfig.requireOrganization && !organization) {
    return (
      <div className={`protected-route-no-org ${className}`}>
        <div className="no-org-container">
          <h2>Organization Required</h2>
          <p>You must be part of an organization to access this page.</p>
          <button
            onClick={() => {% if file.options.nextjs %}router.push('/select-organization'){% else %}window.location.href = '/select-organization'{% endif %}}
            className="select-org-button"
          >
            Select Organization
          </button>
        </div>
      </div>
    );
  }

  // Allowed organizations check
  if (mergedConfig.allowedOrganizations && mergedConfig.allowedOrganizations.length > 0) {
    const isAllowedOrg = organization &&
      mergedConfig.allowedOrganizations.includes(organization.slug || organization.id);

    if (!isAllowedOrg) {
      if (mergedConfig.unauthorizedComponent) {
        const UnauthorizedComponent = mergedConfig.unauthorizedComponent;
        return <UnauthorizedComponent reason="wrong_organization" />;
      }

      return (
        <div className={`protected-route-forbidden ${className}`}>
          <div className="forbidden-container">
            <h2>Access Denied</h2>
            <p>Your current organization doesn't have access to this page.</p>
          </div>
        </div>
      );
    }
  }
  {% endif %}

  // Custom validation
  if (mergedConfig.customValidator) {
    const validationResult = mergedConfig.customValidator(user, {
      isSignedIn,
      userId,
      getToken,
      {% if file.options.organizations %}
      organization,
      membership,
      {% endif %}
    });

    if (validationResult !== true) {
      const reason = typeof validationResult === 'string' ? validationResult : 'custom_validation_failed';

      if (mergedConfig.unauthorizedComponent) {
        const UnauthorizedComponent = mergedConfig.unauthorizedComponent;
        return <UnauthorizedComponent reason={reason} />;
      }

      return (
        <div className={`protected-route-forbidden ${className}`}>
          <div className="forbidden-container">
            <h2>Access Denied</h2>
            <p>{typeof validationResult === 'string' ? validationResult : 'Custom validation failed'}</p>
          </div>
        </div>
      );
    }
  }

  // All checks passed - render protected content
  return (
    <div className={`protected-route-container ${className}`}>
      {children}
    </div>
  );
}

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// Higher-order component for protecting routes
export function withProtectedRoute<P extends object>(
  Component: React.ComponentType<P>,
  config?: ProtectedRouteConfig
) {
  return function ProtectedRouteWrapper(props: P) {
    return (
      <ProtectedRoute config={config}>
        <Component {...props} />
      </ProtectedRoute>
    );
  };
}

// Hook for checking authentication status
export function useAuthGuard(config?: ProtectedRouteConfig) {
  const { isLoaded, isSignedIn, userId } = useAuth();
  const { user } = useUser();
  {% if file.options.organizations %}
  const { organization, membership } = useOrganization();
  {% endif %}

  const checkAccess = React.useCallback(() => {
    if (!isLoaded) return { allowed: false, loading: true };
    if (!config) return { allowed: isSignedIn, loading: false };

    // Basic auth check
    if (config.requireAuth && !isSignedIn) {
      return { allowed: false, loading: false, reason: 'not_authenticated' };
    }

    {% if file.options.role_based %}
    // Role check
    if (config.allowedRoles && config.allowedRoles.length > 0) {
      const userRoles = user?.publicMetadata?.roles as string[] || [];
      const hasValidRole = config.allowedRoles.some(role => userRoles.includes(role));
      if (!hasValidRole) {
        return { allowed: false, loading: false, reason: 'insufficient_role' };
      }
    }

    // Permission check
    if (config.requiredPermissions && config.requiredPermissions.length > 0) {
      const userPermissions = user?.publicMetadata?.permissions as string[] || [];
      const hasRequiredPermissions = config.requiredPermissions.every(permission =>
        userPermissions.includes(permission)
      );
      if (!hasRequiredPermissions) {
        return { allowed: false, loading: false, reason: 'insufficient_permissions' };
      }
    }
    {% endif %}

    {% if file.options.organizations %}
    // Organization checks
    if (config.requireOrganization && !organization) {
      return { allowed: false, loading: false, reason: 'no_organization' };
    }

    if (config.allowedOrganizations && config.allowedOrganizations.length > 0) {
      const isAllowedOrg = organization &&
        config.allowedOrganizations.includes(organization.slug || organization.id);
      if (!isAllowedOrg) {
        return { allowed: false, loading: false, reason: 'wrong_organization' };
      }
    }
    {% endif %}

    // Custom validation
    if (config.customValidator) {
      const result = config.customValidator(user, {
        isSignedIn,
        userId,
        {% if file.options.organizations %}
        organization,
        membership,
        {% endif %}
      });
      if (result !== true) {
        return {
          allowed: false,
          loading: false,
          reason: typeof result === 'string' ? result : 'custom_validation_failed'
        };
      }
    }

    return { allowed: true, loading: false };
  }, [isLoaded, isSignedIn, userId, user, {% if file.options.organizations %}organization, membership,{% endif %} config]);

  return checkAccess();
}

// Utility components
export function LoadingSpinner() {
  return (
    <div className="loading-spinner-container">
      <div className="loading-spinner" />
    </div>
  );
}

export function UnauthorizedMessage({ reason }: { reason: string }) {
  const messages = {
    not_authenticated: 'You must be signed in to access this page.',
    insufficient_role: 'You don\'t have the required role to access this page.',
    insufficient_permissions: 'You don\'t have the required permissions to access this page.',
    no_organization: 'You must be part of an organization to access this page.',
    wrong_organization: 'Your current organization doesn\'t have access to this page.',
    custom_validation_failed: 'Access denied due to custom validation rules.',
  };

  return (
    <div className="unauthorized-message">
      <h2>Access Denied</h2>
      <p>{messages[reason as keyof typeof messages] || 'You are not authorized to access this page.'}</p>
    </div>
  );
}

// TypeScript types
export interface ProtectedRouteProps extends Props {}
export type { ProtectedRouteConfig };

export interface AuthGuardResult {
  allowed: boolean;
  loading: boolean;
  reason?: string;
}
