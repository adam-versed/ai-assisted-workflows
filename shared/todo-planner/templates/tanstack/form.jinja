// {{ file.path }} - TanStack Form Component
// Generated from PRD requirements
{% if file.options.validation %}
// ADVICE: Use schema validation with Zod, Yup, or Valibot for type-safe form validation
{% endif %}
{% if file.options.field_arrays %}
// ADVICE: Use useFieldArray for dynamic form arrays with proper type safety
{% endif %}
{% if file.options.async_validation %}
// ADVICE: Implement async validation for server-side checks like email uniqueness
{% endif %}

import React from 'react';
import { useForm, type FieldApi } from '@tanstack/react-form';
{% if file.options.validation %}
import { zodValidator } from '@tanstack/zod-form-adapter';
import { z } from 'zod';
{% endif %}
{% if file.options.devtools %}
import { TanStackFormDevtools } from '@tanstack/form-devtools';
{% endif %}

{% if file.options.validation %}
// Form validation schema
const formSchema = z.object({
  // TODO: Define form fields based on PRD requirements
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email format'),
  age: z.number().min(18, 'Must be at least 18 years old').optional(),
  role: z.enum(['admin', 'user', 'moderator']).default('user'),
  preferences: z.object({
    notifications: z.boolean().default(true),
    theme: z.enum(['light', 'dark']).default('light'),
  }).optional(),
  {% if file.options.field_arrays %}
  skills: z.array(z.object({
    name: z.string().min(1, 'Skill name is required'),
    level: z.enum(['beginner', 'intermediate', 'advanced']),
  })).min(1, 'At least one skill is required'),
  {% endif %}
});

type FormData = z.infer<typeof formSchema>;
{% else %}
// Form data type (define without validation schema)
interface FormData {
  // TODO: Define form fields based on PRD requirements
  name: string;
  email: string;
  age?: number;
  role: 'admin' | 'user' | 'moderator';
  preferences?: {
    notifications: boolean;
    theme: 'light' | 'dark';
  };
  {% if file.options.field_arrays %}
  skills: Array<{
    name: string;
    level: 'beginner' | 'intermediate' | 'advanced';
  }>;
  {% endif %}
}
{% endif %}

// Form props interface
interface Props {
  initialData?: Partial<FormData>;
  onSubmit: (data: FormData) => Promise<void> | void;
  onCancel?: () => void;
  className?: string;
  disabled?: boolean;
}

// Field component for reusable form inputs
function FieldInfo({ field }: { field: FieldApi<any, any, any, any> }) {
  return (
    <>
      {field.state.meta.isTouched && field.state.meta.errors.length ? (
        <em className="field-error" role="alert">
          {field.state.meta.errors.join(', ')}
        </em>
      ) : null}
      {field.state.meta.isValidating ? (
        <em className="field-validating">Validating...</em>
      ) : null}
    </>
  );
}

{% for function in functions %}
{% if function.name == 'default' or 'form' in function.name.lower() %}
export default function {{ function.name.replace('default', file.path.split('/')[-1].replace('.tsx', '').replace('.jsx', '')) }}({
  initialData,
  onSubmit,
  onCancel,
  className = '',
  disabled = false
}: Props) {
  // TODO: {{ function.prd_references | join(', ') }} - {{ function.description }}

  const form = useForm({
    defaultValues: {
      name: '',
      email: '',
      age: undefined,
      role: 'user' as const,
      preferences: {
        notifications: true,
        theme: 'light' as const,
      },
      {% if file.options.field_arrays %}
      skills: [{ name: '', level: 'beginner' as const }],
      {% endif %}
      ...initialData,
    } as FormData,

    {% if file.options.validation %}
    validatorAdapter: zodValidator(),
    validators: {
      onChange: formSchema,
    },
    {% endif %}

    onSubmit: async ({ value }) => {
      try {
        await onSubmit(value);
      } catch (error) {
        console.error('Form submission error:', error);
        // Handle submission error
        throw error;
      }
    },

    {% if file.options.async_validation %}
    onSubmitInvalid: ({ value, formApi }) => {
      console.log('Form submission invalid:', value);
      // Focus first invalid field
      const firstErrorField = formApi.state.fieldMeta.find(
        field => field.errors.length > 0
      );
      if (firstErrorField) {
        document.querySelector(`[name="${firstErrorField.name}"]`)?.focus();
      }
    },
    {% endif %}
  });

  return (
    <div className={`form-container ${className}`}>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
        className="tanstack-form"
      >
        {/* Form Header */}
        <div className="form-header">
          <h2>{{ function.name.replace('default', file.path.split('/')[-1].replace('.tsx', '').replace('.jsx', '')) }}</h2>
        </div>

        {/* Form Fields */}
        <div className="form-fields">
          {/* Name Field */}
          <form.Field
            name="name"
            {% if file.options.validation %}
            validators={{
              onChange: z.string().min(2, 'Name must be at least 2 characters'),
              {% if file.options.async_validation %}
              onChangeAsync: async (value) => {
                await new Promise(resolve => setTimeout(resolve, 1000));
                return value.includes('test')
                  ? 'Name cannot contain "test"'
                  : undefined;
              },
              {% endif %}
            }}
            {% endif %}
            children={(field) => (
              <div className="form-field">
                <label htmlFor={field.name} className="field-label">
                  Name *
                </label>
                <input
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                  placeholder="Enter your name"
                  className={`field-input ${
                    field.state.meta.errors.length ? 'error' : ''
                  }`}
                  disabled={disabled}
                  required
                />
                <FieldInfo field={field} />
              </div>
            )}
          />

          {/* Email Field */}
          <form.Field
            name="email"
            {% if file.options.validation %}
            validators={{
              onChange: z.string().email('Invalid email format'),
              {% if file.options.async_validation %}
              onChangeAsync: async (value) => {
                if (!value) return undefined;
                await new Promise(resolve => setTimeout(resolve, 1000));
                // Simulate server-side email validation
                return value === 'taken@example.com'
                  ? 'Email is already taken'
                  : undefined;
              },
              {% endif %}
            }}
            {% endif %}
            children={(field) => (
              <div className="form-field">
                <label htmlFor={field.name} className="field-label">
                  Email *
                </label>
                <input
                  id={field.name}
                  name={field.name}
                  type="email"
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value)}
                  placeholder="Enter your email"
                  className={`field-input ${
                    field.state.meta.errors.length ? 'error' : ''
                  }`}
                  disabled={disabled}
                  required
                />
                <FieldInfo field={field} />
              </div>
            )}
          />

          {/* Age Field (Optional) */}
          <form.Field
            name="age"
            {% if file.options.validation %}
            validators={{
              onChange: z.number().min(18, 'Must be at least 18 years old').optional(),
            }}
            {% endif %}
            children={(field) => (
              <div className="form-field">
                <label htmlFor={field.name} className="field-label">
                  Age
                </label>
                <input
                  id={field.name}
                  name={field.name}
                  type="number"
                  value={field.state.value || ''}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(
                    e.target.value ? Number(e.target.value) : undefined
                  )}
                  placeholder="Enter your age"
                  className={`field-input ${
                    field.state.meta.errors.length ? 'error' : ''
                  }`}
                  disabled={disabled}
                  min="18"
                />
                <FieldInfo field={field} />
              </div>
            )}
          />

          {/* Role Field */}
          <form.Field
            name="role"
            {% if file.options.validation %}
            validators={{
              onChange: z.enum(['admin', 'user', 'moderator']),
            }}
            {% endif %}
            children={(field) => (
              <div className="form-field">
                <label htmlFor={field.name} className="field-label">
                  Role *
                </label>
                <select
                  id={field.name}
                  name={field.name}
                  value={field.state.value}
                  onBlur={field.handleBlur}
                  onChange={(e) => field.handleChange(e.target.value as FormData['role'])}
                  className={`field-select ${
                    field.state.meta.errors.length ? 'error' : ''
                  }`}
                  disabled={disabled}
                  required
                >
                  <option value="user">User</option>
                  <option value="admin">Admin</option>
                  <option value="moderator">Moderator</option>
                </select>
                <FieldInfo field={field} />
              </div>
            )}
          />

          {/* Nested Preferences Fields */}
          <div className="form-section">
            <h3>Preferences</h3>

            <form.Field
              name="preferences.notifications"
              children={(field) => (
                <div className="form-field checkbox-field">
                  <label className="checkbox-label">
                    <input
                      type="checkbox"
                      checked={field.state.value || false}
                      onChange={(e) => field.handleChange(e.target.checked)}
                      onBlur={field.handleBlur}
                      className="field-checkbox"
                      disabled={disabled}
                    />
                    Enable Notifications
                  </label>
                  <FieldInfo field={field} />
                </div>
              )}
            />

            <form.Field
              name="preferences.theme"
              children={(field) => (
                <div className="form-field">
                  <label htmlFor={field.name} className="field-label">
                    Theme
                  </label>
                  <select
                    id={field.name}
                    name={field.name}
                    value={field.state.value || 'light'}
                    onBlur={field.handleBlur}
                    onChange={(e) => field.handleChange(e.target.value as 'light' | 'dark')}
                    className="field-select"
                    disabled={disabled}
                  >
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                  </select>
                  <FieldInfo field={field} />
                </div>
              )}
            />
          </div>

          {% if file.options.field_arrays %}
          {/* Dynamic Skills Array */}
          <div className="form-section">
            <h3>Skills</h3>

            <form.Field
              name="skills"
              mode="array"
              children={(field) => (
                <div className="field-array">
                  {field.state.value.map((_, index) => (
                    <div key={index} className="array-item">
                      <form.Field
                        name={`skills.${index}.name`}
                        {% if file.options.validation %}
                        validators={{
                          onChange: z.string().min(1, 'Skill name is required'),
                        }}
                        {% endif %}
                        children={(skillField) => (
                          <div className="form-field">
                            <label className="field-label">
                              Skill Name
                            </label>
                            <input
                              value={skillField.state.value}
                              onBlur={skillField.handleBlur}
                              onChange={(e) => skillField.handleChange(e.target.value)}
                              placeholder="e.g., TypeScript"
                              className={`field-input ${
                                skillField.state.meta.errors.length ? 'error' : ''
                              }`}
                              disabled={disabled}
                            />
                            <FieldInfo field={skillField} />
                          </div>
                        )}
                      />

                      <form.Field
                        name={`skills.${index}.level`}
                        children={(levelField) => (
                          <div className="form-field">
                            <label className="field-label">
                              Level
                            </label>
                            <select
                              value={levelField.state.value}
                              onBlur={levelField.handleBlur}
                              onChange={(e) => levelField.handleChange(
                                e.target.value as 'beginner' | 'intermediate' | 'advanced'
                              )}
                              className="field-select"
                              disabled={disabled}
                            >
                              <option value="beginner">Beginner</option>
                              <option value="intermediate">Intermediate</option>
                              <option value="advanced">Advanced</option>
                            </select>
                            <FieldInfo field={levelField} />
                          </div>
                        )}
                      />

                      <button
                        type="button"
                        onClick={() => field.removeValue(index)}
                        className="remove-button"
                        disabled={disabled || field.state.value.length <= 1}
                      >
                        Remove
                      </button>
                    </div>
                  ))}

                  <button
                    type="button"
                    onClick={() => field.pushValue({ name: '', level: 'beginner' })}
                    className="add-button"
                    disabled={disabled}
                  >
                    Add Skill
                  </button>
                  <FieldInfo field={field} />
                </div>
              )}
            />
          </div>
          {% endif %}
        </div>

        {/* Form Actions */}
        <div className="form-actions">
          <form.Subscribe
            selector={(state) => [state.canSubmit, state.isSubmitting]}
            children={([canSubmit, isSubmitting]) => (
              <button
                type="submit"
                className="submit-button primary"
                disabled={!canSubmit || disabled}
              >
                {isSubmitting ? 'Submitting...' : 'Submit'}
              </button>
            )}
          />

          {onCancel && (
            <button
              type="button"
              onClick={onCancel}
              className="cancel-button secondary"
              disabled={disabled}
            >
              Cancel
            </button>
          )}

          <button
            type="button"
            onClick={() => form.reset()}
            className="reset-button tertiary"
            disabled={disabled}
          >
            Reset
          </button>
        </div>

        {/* Form Debug Info (Development) */}
        {process.env.NODE_ENV === 'development' && (
          <div className="form-debug">
            <details>
              <summary>Form Debug</summary>
              <form.Subscribe
                selector={(state) => [state.values, state.errors, state.fieldMeta]}
                children={([values, errors, fieldMeta]) => (
                  <div className="debug-content">
                    <div>
                      <strong>Values:</strong>
                      <pre>{JSON.stringify(values, null, 2)}</pre>
                    </div>
                    <div>
                      <strong>Errors:</strong>
                      <pre>{JSON.stringify(errors, null, 2)}</pre>
                    </div>
                    <div>
                      <strong>Field Meta:</strong>
                      <pre>{JSON.stringify(fieldMeta, null, 2)}</pre>
                    </div>
                  </div>
                )}
              />
            </details>
          </div>
        )}
      </form>

      {% if file.options.devtools %}
      {/* TanStack Form Devtools */}
      {process.env.NODE_ENV === 'development' && (
        <TanStackFormDevtools form={form} />
      )}
      {% endif %}
    </div>
  );
}

{% else %}
{{ function.stub_code }}

{% endif %}
{% endfor %}

// Form utility hooks
export function useFormHelpers() {
  return {
    validateEmail: (email: string) => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    },

    validatePhone: (phone: string) => {
      const phoneRegex = /^\+?[\d\s\-\(\)]+$/;
      return phoneRegex.test(phone) && phone.replace(/\D/g, '').length >= 10;
    },

    formatCurrency: (amount: number) => {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
      }).format(amount);
    },

    debounceValidation: (fn: Function, delay: number = 300) => {
      let timeoutId: NodeJS.Timeout;
      return (...args: any[]) => {
        clearTimeout(timeoutId);
        return new Promise((resolve) => {
          timeoutId = setTimeout(() => resolve(fn(...args)), delay);
        });
      };
    },
  };
}

// Custom form field components
export function FormField({
  label,
  error,
  required = false,
  children,
  className = '',
}: {
  label: string;
  error?: string;
  required?: boolean;
  children: React.ReactNode;
  className?: string;
}) {
  return (
    <div className={`form-field ${className} ${error ? 'has-error' : ''}`}>
      <label className="field-label">
        {label}
        {required && <span className="required-indicator">*</span>}
      </label>
      {children}
      {error && (
        <span className="field-error" role="alert">
          {error}
        </span>
      )}
    </div>
  );
}

// TypeScript types
export interface FormComponentProps extends Props {}
export type { FormData };
{% if file.options.validation %}
export { formSchema };
{% endif %}
